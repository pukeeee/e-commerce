# Стратегія Кешування

## 1. Огляд

Кешування є ключовим елементом архітектури цього проекту, спрямованим на досягнення двох основних цілей:
1.  **Максимальна продуктивність:** Миттєве завантаження сторінок та відгук інтерфейсу.
2.  **Ефективне використання ресурсів:** Зниження навантаження на базу даних та сервер.

З точки зору бізнесу, це призводить до покращення користувацького досвіду (UX), підвищення конверсії та потенційного зниження витрат на інфраструктуру.

## 2. Архітектура Кешування

На даному етапі в проекті реалізовано **Серверний Кеш Даних (Data Cache)**.

-   **Що це:** Ми кешуємо результати "важких" запитів до бази даних безпосередньо на сервері.
-   **Технологія:** Використовується вбудований в Next.js механізм `unstable_cache` (Data Cache).
-   **Принцип:** Коли виконується запит на отримання даних (наприклад, списку товарів), результат зберігається в пам'яті сервера на певний час. Наступні запити на ті ж дані отримують відповідь миттєво з кешу, не звертаючись до бази даних.

## 3. Реалізація Серверного Кешу Даних

### Принцип Роботи

Ми використовуємо патерн "обгортка" (wrapper). Кожна функція, що виконує запит до бази даних, обгортається у спеціальну кешуючу функцію, яка керує логікою кешування.

### Ключові Абстракції

Для стандартизації роботи з кешем в проекті існують утиліти в `shared/lib/cache.ts`:

-   `createCachedFunction`: Основна утиліта, що створює кешовану версію будь-якої функції запиту даних. Вона приймає саму функцію, ключ кешу та опції.
-   `CACHE_TAGS`: Централізований об'єкт для керування **тегами** кешу. Теги — це мітки, які ми "вішаємо" на кешовані дані, щоб потім мати можливість їх групової інвалідації. Наприклад, всі товари мають тег `products`, а конкретний товар — `products:123`.
-   `CACHE_TIMES`: Централізований об'єкт з константами часу життя кешу (в секундах).

### Час Життя та Ревалідація

Кожен елемент кешу має параметр `revalidate` — час у секундах, протягом якого дані вважаються "свіжими". Після закінчення цього часу дані стають "застарілими" (stale).

Проект використовує стратегію **stale-while-revalidate**:
1.  Користувач запитує дані.
2.  Якщо в кеші є "застарілі" дані, система **миттєво** віддає їх користувачу (щоб він не чекав).
3.  **Одночасно** у фоновому режимі система виконує реальний запит до бази даних, щоб оновити кеш свіжими даними для наступних користувачів.

### Інвалідація Кешу (Cache Invalidation)

Інвалідація — це процес примусового очищення кешу. Наприклад, коли адміністратор оновив назву товару, нам потрібно скинути кеш для цього товару.

Архітектура системи побудована з розрахунком на це. Завдяки використанню тегів, кеш можна інвалідувати централізовано. Виклик функції Next.js `revalidateTag('products')` дозволяє примусово очистити всі записи в кеші, що позначені відповідним тегом.

## 4. Практичне Застосування

### Як кешувати новий запит

1.  У відповідному репозиторії (напр., `product.repository.ts`) створіть звичайну асинхронну функцію для отримання даних (напр., `getSomethingUncached`).
2.  Створіть кешовану версію, обгорнувши її в `createCachedFunction`.
3.  Вкажіть унікальний ключ, час ревалідації з `CACHE_TIMES` та відповідні теги з `CACHE_TAGS`.
4.  Експортуйте кешовану функцію як частину об'єкта репозиторію.

### Коли НЕ кешувати

**Ніколи не кешуйте функції, які змінюють дані** (створення, оновлення, видалення). Кешуванню підлягають лише операції читання (GET-запити). Прикладом є метод `orderRepository.create`, який не обгорнутий у кеш.