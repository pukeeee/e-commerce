# Стратегія Кешування

## 1. Огляд

Кешування є ключовим елементом архітектури цього проекту, спрямованим на досягнення двох основних цілей:
1.  **Максимальна продуктивність:** Миттєве завантаження сторінок та відгук інтерфейсу.
2.  **Ефективне використання ресурсів:** Зниження навантаження на базу даних та сервер.

З точки зору бізнесу, це призводить до покращення користувацького досвіду (UX), підвищення конверсії та потенційного зниження витрат на інфраструктуру.

## 2. Архітектура Кешування

На даному етапі в проекті реалізовано **Серверний Кеш Даних (Data Cache)**.

-   **Що це:** Ми кешуємо результати "важких" запитів до бази даних безпосередньо на сервері.
-   **Технологія:** Використовується вбудований в Next.js механізм `unstable_cache` (Data Cache).
-   **Принцип:** Коли виконується запит на отримання даних, результат зберігається в спільному для всіх користувачів кеші на певний час. Наступні запити на ті ж дані отримують відповідь миттєво з кешу.

## 3. Реалізація Серверного Кешу Даних

### Принцип Роботи: Впровадження Залежностей

Ключовий принцип кешування в Next.js: **функція, що кешується, має бути "чистою" з точки зору динамічних даних**. Вона не може містити код, що залежить від конкретного користувача, наприклад, виклик `cookies()`.

Наша функція `createClient()` для Supabase є динамічною, оскільки вона використовує cookies для ідентифікації користувача. Щоб вирішити цей конфлікт, ми застосовуємо патерн **Dependency Injection (Впровадження залежностей)**:

1.  **Рівень Server Action:** Тут створюється динамічний, залежний від користувача `SupabaseClient`.
2.  **Рівень Репозиторію:** Методи репозиторію більше не створюють клієнт самі. Вони отримують його як аргумент від Server Action.

Таким чином, сама функція репозиторію, що робить запит до БД, стає "чистою" і може бути безпечно кешована.

### Ключові Абстракції

Для стандартизації роботи з кешем в проекті існують утиліти в `shared/lib/cache.ts`:

-   `createCachedFunction`: Основна утиліта, що створює кешовану версію будь-якої функції запиту даних.
-   `CACHE_TAGS`: Централізований об'єкт для керування тегами кешу.
-   `CACHE_TIMES`: Централізований об'єкт з константами часу життя кешу.

### Час Життя та Ревалідація

Проект використовує стратегію **stale-while-revalidate**: система миттєво віддає застарілі дані з кешу, одночасно запускаючи у фоні їх оновлення.

### Інвалідація Кешу (Cache Invalidation)

Завдяки використанню тегів, кеш можна інвалідувати централізовано. Виклик функції Next.js `revalidateTag('products')` дозволяє примусово очистити всі записи в кеші, що позначені відповідним тегом.

## 4. Практичне Застосування

### Як кешувати новий запит

1.  **Оновіть інтерфейс** (`IYourRepository`): додайте `supabase: SupabaseClient` як перший аргумент до сигнатури методу.
2.  **В репозиторії:**
    -   Створіть некешовану функцію (`getSomethingUncached`), яка приймає `supabase` як аргумент і робить запит до БД.
    -   Створіть кешовану функцію-обгортку, яка також приймає `supabase` і передає його в `createCachedFunction`.
3.  **В Server Action:**
    -   Створіть клієнт: `const supabase = await createClient();`.
    -   Викличте метод репозиторію, передавши в нього клієнт: `await repository.getSomething(supabase, ...)`. 

### Коли НЕ кешувати

**Ніколи не кешуйте функції, які змінюють дані** (створення, оновлення, видалення). Кешуванню підлягають лише операції читання. Навіть для некешованих мутацій, як `orderRepository.create`, ми все одно передаємо `SupabaseClient` як аргумент для збереження консистентності архітектури.
