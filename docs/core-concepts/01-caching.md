# Стратегія Кешування

## 1. Огляд

Кешування є ключовим елементом архітектури цього проекту, спрямованим на досягнення двох основних цілей:
1.  **Максимальна продуктивність:** Миттєве завантаження сторінок та відгук інтерфейсу.
2.  **Ефективне використання ресурсів:** Зниження навантаження на базу даних та сервер.

З точки зору бізнесу, це призводить до покращення користувацького досвіду (UX), підвищення конверсії та потенційного зниження витрат на інфраструктуру.

## 2. Архітектура Кешування

На даному етапі в проекті реалізовано **Серверний Кеш Даних (Data Cache)**.

-   **Що це:** Ми кешуємо результати "важких" запитів до бази даних безпосередньо на сервері.
-   **Технологія:** Використовується вбудований в Next.js механізм `unstable_cache` (Data Cache).
-   **Принцип:** Коли виконується запит на отримання даних, результат зберігається в спільному для всіх користувачів кеші на певний час. Наступні запити на ті ж дані отримують відповідь миттєво з кешу.

## 3. Реалізація Серверного Кешу Даних

### Принцип Роботи: Впровадження Залежностей

Ключовий принцип кешування в Next.js: **функція, що кешується, має бути "чистою" з точки зору динамічних даних**. Вона не може містити код, що залежить від конкретного користувача, наприклад, виклик `cookies()`.

Наша функція `createClient()` для Supabase є динамічною, оскільки вона використовує cookies для ідентифікації користувача. Щоб вирішити цей конфлікт, ми застосовуємо патерн **Dependency Injection (Впровадження залежностей)**:

1.  **Рівень Server Action:** Тут створюється динамічний, залежний від користувача `SupabaseClient`.
2.  **Рівень Репозиторію:** Методи репозиторію більше не створюють клієнт самі. Вони отримують його як аргумент від Server Action.

Таким чином, сама функція репозиторію, що робить запит до БД, стає "чистою" і може бути безпечно кешована.

### Ключові Абстракції

Для стандартизації роботи з кешем в проекті існують утиліти в `shared/lib/cache.ts`:

-   `createCachedFunction`: Основна утиліта, що створює кешовану версію будь-якої функції запиту даних.
-   `CACHE_TAGS`: Централізований об'єкт для керування тегами кешу.
-   `CACHE_TIMES`: Централізований об'єкт з константами часу життя кешу.

### Час Життя та Ревалідація

Проект використовує стратегію **stale-while-revalidate**: система миттєво віддає застарілі дані з кешу, одночасно запускаючи у фоні їх оновлення.

### Інвалідація Кешу (Cache Invalidation)

Завдяки використанню тегів, кеш можна інвалідувати централізовано. Виклик функції Next.js `revalidateTag('products')` дозволяє примусово очистити всі записи в кеші, що позначені відповідним тегом.

## 4. Практичне Застосування

### Як кешувати новий запит

1.  **Оновіть інтерфейс** (`IYourRepository`): додайте `supabase: SupabaseClient` як перший аргумент до сигнатури методу.
2.  **В репозиторії:**
    -   Створіть некешовану функцію (`getSomethingUncached`), яка приймає `supabase` як аргумент і робить запит до БД.
    -   Створіть кешовану функцію-обгортку, яка також приймає `supabase` і передає його в `createCachedFunction`.
3.  **В Server Action:**
    -   Створіть клієнт: `const supabase = await createClient();`.
    -   Викличте метод репозиторію, передавши в нього клієнт: `await repository.getSomething(supabase, ...)`. 

### Коли НЕ кешувати

**Ніколи не кешуйте функції, які змінюють дані** (створення, оновлення, видалення). Кешуванню підлягають лише операції читання. Навіть для некешованих мутацій, як `orderRepository.create`, ми все одно передаємо `SupabaseClient` як аргумент для збереження консистентності архітектури.

## 5. Інші Стратегії Оптимізації та Кешування

Окрім серверного кешування даних, проект використовує інші механізми для прискорення завантаження та покращення продуктивності.

### Інкрементальна Статична Регенерація (ISR)

-   **Що це:** Це потужна функція Next.js, яка дозволяє періодично оновлювати статично згенеровані сторінки у фоновому режимі.
-   **Застосування:** Головна сторінка (`/`) використовує ISR з періодом ревалідації в 1 годину (`export const revalidate = 3600`).
-   **Переваги:** Користувачі завжди отримують сторінку миттєво (як статичний HTML), але при цьому дані на ній (наприклад, список товарів) залишаються відносно актуальними, оновлюючись без необхідності повного перезавантаження сайту.

### Оптимізація Завантаження Ресурсів (Resource Hints)

Для прискорення завантаження критичних ресурсів ми використовуємо спеціальні HTML-теги в `<head>` нашого головного лейаута (`src/app/layout.tsx`):

-   **`<link rel="preconnect">`**: Завчасно встановлює з'єднання з доменом Supabase. Це економить час на DNS-пошук, TCP-хендшейк та TLS-переговори, коли надсилається перший реальний запит до бази даних або сховища.
-   **`<link rel="preload">`**: Дає браузеру команду негайно завантажити критично важливий ресурс, не чекаючи, поки він знадобиться. Ми використовуємо це для основного файлу шрифта, що значно покращує показник LCP (Largest Contentful Paint).

### Обмеження Частоти Запитів на Клієнті (Throttling)

-   **Проблема:** Деякі дії користувача, як-от відкриття кошика, можуть ініціювати запити до сервера для синхронізації даних. Якщо робити це кожного разу, створюється зайве навантаження.
-   **Рішення:** В компоненті кошика (`CartSheet.tsx`) реалізовано механізм "throttling". Запит на синхронізацію відправляється не частіше, ніж раз на 5 хвилин.
-   **Реалізація:** За допомогою `useRef` для зберігання часу останньої синхронізації та порівняння з `Date.now()` ми приймаємо рішення, чи потрібно виконувати запит. Це простий, але ефективний спосіб клієнтської оптимізації для уникнення "шторму" запитів.
