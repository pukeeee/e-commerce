# Стратегія Оптимізації Зображень

## 1. Огляд

Оптимізація зображень є фундаментальним аспектом продуктивності цього проекту. Стратегія спрямована на досягнення двох основних цілей:
1.  **Максимальна продуктивність:** Забезпечення миттєвого візуального завантаження сторінок шляхом зменшення розміру зображень, що передаються клієнту.
2.  **Ефективне використання ресурсів:** Зниження витрат трафіку для користувачів та розвантаження власного сервера від задач обробки зображень.

З точки зору бізнесу, це напряму впливає на покращення користувацького досвіду (UX), підвищення показників утримання та конверсії.

## 2. Архітектура Оптимізації: Supabase Image Transformation

Проект використовує **вбудований в Supabase сервіс трансформації зображень**. Цей підхід є значно ефективнішим за самостійну обробку, оскільки перекладає всю важку роботу на інфраструктуру Supabase, яка оптимізована для цих задач і використовує глобальну мережу доставки контенту (CDN).

*   **Принцип роботи:** Запити на зображення від компонента `next/image` перехоплюються, а їх URL динамічно модифікується, щоб вказувати на ендпоінт трансформації зображень Supabase замість прямого посилання на файл.
*   **Технології:**
    *   **`next/image`:** Використовується для забезпечення стабільності макету (CLS), доступності та як точка входу для запуску процесу оптимізації.
    *   **Supabase Image Transformation API:** Потужний сервіс для зміни розміру, якості та формату зображень "на льоту".
    *   **Кастомний `loaderFile` в Next.js:** Механізм для перехоплення та модифікації URL зображень.

**Ключова перевага:** Завдяки такому підходу відсутня необхідність підтримувати власний API-ендпоінт (`/api/image`) та важку залежність (`sharp`), що робить архітектуру простішою, надійнішою та дешевшою в експлуатації.

## 3. Реалізація

### Принцип Роботи: Ланцюжок Обробки

1.  **Перехоплення (Interception):** Файл `next.config.ts` налаштований з опціями `loader: 'custom'` та `loaderFile`. Це змушує Next.js для кожного компонента `<Image>` викликати кастомний завантажувач проекту (`src/shared/lib/image-loader.ts`) замість стандартної логіки.

2.  **Трансформація URL (URL Transformation):** Кастомний завантажувач функціонує як "диспетчер". Він приймає `src` оригінального зображення та параметри (`width`, `quality`) від компонента `<Image>` і виконує наступні дії:
    *   Перевіряє, чи є `src` посиланням на об'єкт у Supabase Storage.
    *   Якщо так, він перетворює стандартний URL об'єкта на URL для трансформації.
        *   *Вхід:* `https://<id>.supabase.co/storage/v1/object/public/images/product.jpg`
        *   *Вихід:* `https://<id>.supabase.co/storage/v1/render/image/public/images/product.jpg?width=800&quality=80&resize=contain`
    *   Якщо `src` не є посиланням на Supabase, він повертається без змін.

3.  **Обробка та Кешування в Supabase:** Supabase отримує запит, обробляє зображення згідно з параметрами в URL, і повертає оптимізований результат. Важливо, що Supabase автоматично кешує трансформовані зображення на своєму CDN. Це означає, що дорога операція обробки виконується **лише один раз**, а всі наступні запити миттєво віддаються з кешу.

## 4. Практичне Застосування

Для коректної роботи системи розробник повинен дотримуватися кількох правил при використанні компонента `<Image>`.

### 1. Властивість `sizes`

Ця властивість є **критично важливою** для продуктивності. Вона вказує, який розмір зображення буде завантажено для різних розмірів екрану.

*   **Для адаптивних сіток (каталог):**
    ```tsx
    <Image
      fill
      sizes="(max-width: 640px) 50vw, (max-width: 1024px) 33vw, 25vw"
      // ...
    />
    ```
    Це означає: на екранах до 640px ширина зображення дорівнює 50% ширини екрану, до 1024px — 33%, а на більших — 25%.

### 2. Властивість `priority`

Для зображень, які знаходяться у першому видимому екрані (Above the Fold), необхідно додавати властивість `priority`. Це дає сигнал Next.js для пріоритетного завантаження. Для таких зображень також явно вказується `loading="eager"`.

```tsx
<Image
  // ...
  priority={isPriority}
  loading={isPriority ? "eager" : "lazy"}
/>
```

### 3. Покращення UX: `placeholder`

Для покращення візуального досвіду під час завантаження зображень використовується `placeholder="blur"` разом з `blurDataURL`. Це показує розмиту, надлегку версію зображення, поки завантажується оригінал.

```tsx
<Image
  // ...
  placeholder="blur"
  blurDataURL="data:image/svg+xml;base64,..." // Мінімалістичний SVG як заглушка
/>
```
Цей підхід створює відчуття швидшого завантаження і усуває "стрибки" контенту.