# Стратегія Оптимізації Зображень

## 1. Огляд

Оптимізація зображень є фундаментальним аспектом продуктивності цього проекту. Стратегія спрямована на досягнення двох основних цілей:
1.  **Максимальна продуктивність:** Забезпечення миттєвого візуального завантаження сторінок шляхом зменшення розміру зображень, що передаються клієнту.
2.  **Ефективне використання ресурсів:** Зниження витрат трафіку для користувачів та уникнення лімітів і потенційних витрат на інфраструктуру хостинг-платформи.

З точки зору бізнесу, це напряму впливає на покращення користувацького досвіду (UX), підвищення показників утримання та конверсії.

## 2. Архітектура Оптимізації

В проекті реалізовано патерн **"Власний Image CDN на основі Next.js"**. Цей підхід дозволяє виконувати оптимізацію зображень "на льоту" за допомогою внутрішнього API, замість того, щоб покладатися на зовнішні сервіси або вбудовані рішення платформи.

*   **Що це:** Ми перехоплюємо всі запити на зображення від компонента `next/image` і направляємо їх на власний серверний обробник, який динамічно оптимізує та кешує результат.
*   **Технології:**
    *   **`next/image`:** Використовується для забезпечення стабільності макету (CLS), доступності та як точка входу для запуску процесу оптимізації.
    *   **`sharp`:** Високопродуктивна Node.js бібліотека для маніпуляцій із зображеннями (зміна розміру, формату, виправлення орієнтації).
    *   **Next.js Route Handler:** Ізольований, масштабований ендпоінт (`/api/image`), що виконує логіку обробки.
    *   **Заголовок `Cache-Control`:** Механізм для інструктування браузерів та CDN щодо довготривалого кешування оптимізованих зображень.

## 3. Реалізація

### Принцип Роботи: Ланцюжок Обробки

1.  **Перехоплення (Interception):** Файл `next.config.ts` налаштований з опціями `loader: 'custom'` та `loaderFile`. Це змушує Next.js для кожного компонента `<Image>` викликати наш кастомний завантажувач замість стандартної логіки.

2.  **Формування Запиту (Request Formation):** Кастомний завантажувач (`src/shared/lib/image-loader.ts`) функціонує як "диспетчер". Він приймає `src` оригінального зображення та параметри (`width`, `quality`) від компонента `<Image>` і конструює з них новий URL, що вказує на наш внутрішній API.
    *   *Вхід:* `https://.../original.jpg`, `width: 800`
    *   *Вихід:* `/api/image?url=https%3A%2F%2F...&w=800&q=75`

3.  **Обробка "На Льоту" (On-the-Fly Processing):** Браузер робить запит до `/api/image/route.ts`. Цей обробник виконує основну роботу:
    *   Завантажує оригінальний файл зображення зі сховища (Supabase).
    *   Запускає конвеєр обробки `sharp`:
        1.  `.rotate()`: Автоматично виправляє орієнтацію на основі EXIF-метаданих.
        2.  `.resize(width)`: Змінює розмір до потрібної ширини.
        3.  `.webp({ quality })`: Конвертує зображення в сучасний, ефективний формат WebP.
    *   Повертає оптимізоване зображення як `Response`.

### Кешування та Продуктивність

Ключовим елементом продуктивності є HTTP-заголовок, який повертає API-обробник:
`Cache-Control: public, max-age=31536000, immutable`

*   `public`: Дозволяє кешувати відповідь не тільки в браузері, але і на проміжних CDN-серверах (наприклад, Vercel Edge Network).
*   `max-age=31536000`: Встановлює час життя кешу на 1 рік.
*   `immutable`: Сигналізує, що за цим URL контент ніколи не зміниться.

Це означає, що дорога операція обробки зображення за допомогою `sharp` виконується **лише один раз** для кожного унікального набору параметрів (URL, ширина, якість). Всі наступні мільйони запитів на це ж зображення будуть миттєво віддаватися з найближчого до користувача кешу CDN.

## 4. Практичне Застосування

### Використання в Компонентах

Для коректної роботи системи розробник повинен дотримуватися кількох правил при використанні компонента `<Image>`.

#### 1. Використання `fill` для Адаптивності

Завжди використовуйте властивість `fill` замість `width` та `height`, коли зображення має заповнювати адаптивний контейнер. Батьківський елемент при цьому повинен мати `position: relative` та задані розміри.

#### 2. Властивість `sizes`

Ця властивість є **критично важливою** для продуктивності. Вона вказує, який розмір зображення буде завантажено для різних розмірів екрану.

*   **Для адаптивних сіток (каталог):**
    ```tsx
    <Image
      fill
      sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
      // ...
    />
    ```
    Це означає: на екранах до 768px ширина зображення дорівнює 100% ширини екрану, до 1200px — 50%, а на більших — 33%.

*   **Для фіксованих контейнерів (кошик):**
    ```tsx
    <Image
      fill
      sizes="96px" // Контейнер завжди 96px
      // ...
    />
    ```

#### 3. Властивість `priority`

Для зображень, які знаходяться у першому видимому екрані при завантаженні сторінки (Above the Fold), необхідно додавати властивість `priority`. Це вимикає для них відкладене завантаження (`lazy loading`) і змушує браузер завантажити їх якомога раніше, що покращує показник LCP (Largest Contentful Paint).

```tsx
<Image
  // ...
  priority={isPriority} // isPriority - це boolean
  loading={isPriority ? undefined : "lazy"}
/>
```
